# 2020_5-31_CodePractice

//标题：构建乘积数组
// 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素
// B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n- 1]。不能使用除法。

//【题目解析】：
//本题是剑指offer上的原题，构建一个数组，此数组的每个位置上的元素是由原数组相同位置i之前
//的所有元素相乘得来的。
//【解题思路】：
//B[i]的值可以看作下图的矩阵中每行的乘积。
//下三角用连乘可以很容求得，上三角，从下向上也是连乘。
//因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按
//上三角中的分布规律，把另一部分也乘进去。
// B[0]:       1    A[1]   A[2]   ...   A[n-2]    A[n-1]
// B[1]:     A[0]    1     A[2]   ...   A[n-2]    A[n-1]
// B[2]:     A[0]   A[1]    1     ...   A[n-2]    A[n-1]
// ... :     A[0]   A[1]   ...     1    A[n-2]    A[n-1]
// B[n-2]:   A[0]   A[1]   ...  A[n-3]    1       A[n-1]
// B[n-1]:   A[0]   A[1]   ...  A[n-3]  A[n-2]     1

//解释下代码，设有数组大小为5。
//对于第一个for循环
//第一步：b[0] = 1;
//第二步：b[1] = b[0] * a[0] = a[0]
//第三步：b[2] = b[1] * a[1] = a[0] * a[1];
//第四步：b[3] = b[2] * a[2] = a[0] * a[1] * a[2];
//第五步：b[4] = b[3] * a[3] = a[0] * a[1] * a[2] * a[3];
//然后对于第二个for循环
//第一步
//temp *= a[4] = a[4];
//b[3] = b[3] * temp = a[0] * a[1] * a[2] * a[4];
//第二步
//temp *= a[3] = a[4] * a[3];
//b[2] = b[2] * temp = a[0] * a[1] * a[4] * a[3];
//第三步
//temp *= a[2] = a[4] * a[3] * a[2];
//b[1] = b[1] * temp = a[0] * a[4] * a[3] * a[2];
//第四步
//temp *= a[1] = a[4] * a[3] * a[2] * a[1];
//b[0] = b[0] * temp = a[4] * a[3] * a[2] * a[1];
//由此可以看出从b[4]到b[0]均已经得到正确计算。

public class day11_02 {
    public static int[] multiply(int[] a){
        int len=a.length;
        int[] B=new int[len];
        if(len!=0) {
            B[0] = 1;
            //先计算下三角
            for (int i = 1; i < len; i++) {
                B[i] = B[i - 1] * a[i - 1];
            }
            //计算上三角
            int temp = 1;
            for (int j = len - 2; j >= 0; j--) {
                temp *= a[j + 1];
                B[j] *= temp;
            }
        }
        return B;
    }   
}
